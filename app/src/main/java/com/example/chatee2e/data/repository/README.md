# Пакет: com.example.chatee2e.data.repository

Даний пакет містить реалізацію репозиторіїв, які виступають єдиною точкою доступу до даних для шару бізнес-логіки (Domain). Репозиторії координують роботу між мережевим джерелом (Firebase), локальною базою даних (Room) та менеджером безпеки (CryptoManager).

## Основні компоненти та алгоритми

### 1. AuthRepositoryImpl
Відповідає за життєвий цикл облікового запису користувача та автентифікацію.
* **SignUp/SignIn**: Реалізує реєстрацію та вхід через Firebase Auth. При успішному вході автоматично ініціалізується `CryptoManager` для перевірки наявності апаратних ключів. Публічний ключ користувача оновлюється у Firestore, щоб зробити його доступним для інших учасників.
* **DeleteAccount (Критичний шлях)**: Виконує повне видалення цифрового сліду користувача. Алгоритм включає:
    1. Повторну автентифікацію для підтвердження прав.
    2. Видалення документа користувача та його чатів із Firestore.
    3. Апаратне стирання ключів через `cryptoManager.deleteKeys()`.
    4. Повне очищення локальних баз даних та сесії.

### 2. ChatRepositoryImpl
Керує створенням чатів та синхронізацією метаданих.
* **Синхронізація (Real-time)**: Використовує `SnapshotListener` для відстеження нових запрошень (invites) та оновлень у чатах. При отриманні нового чату автоматично підвантажує дані учасників та зберігає їх у локальну БД `ChatDao` у форматі JSON.
* **Управління ключем БД**: Перед першим доступом до бази даних реалізує алгоритм `setupDatabaseKey`. Він дешифрує пароль бази за допомогою апаратного майстер-ключа, отриманого з KeyStore, та передає його в `SessionManager`.



### 3. MessageRepositoryImpl
Найбільш складний модуль, що реалізує логіку наскрізного шифрування (E2EE) для повідомлень.
* **Відправка повідомлення (Encryption Flow)**:
    1. Генерує унікальний симетричний сесійний ключ `aesKey`.
    2. Шифрує текст повідомлення за допомогою `aesKey`.
    3. Отримує публічні ключі RSA всіх учасників чату.
    4. Шифрує `aesKey` публічним ключем кожного учасника окремо, створюючи карту `encryptedKeys`.
    5. Відправляє зашифрований пакет (ciphertext + IV + keys map) у Firestore.
* **Отримання повідомлення (Decryption Flow)**:
    1. Перехоплює новий пакет із Firestore.
    2. Вилучає з `encryptedKeys` ключ, призначений для поточного користувача.
    3. Дешифрує його приватним ключем RSA, що зберігається в KeyStore.
    4. Отриманим сесійним ключем дешифрує текст повідомлення та зберігає результат у `messageDao`.



### 4. UserRepositoryImpl
Забезпечує управління соціальними функціями та профілями.
* **Блокування користувачів**: Реалізує логіку "Blacklist" через підколекції Firestore.
* **Списки користувачів**: Забезпечує отримання списку доступних контактів, фільтруючи ідентифікатор поточного авторизованого користувача.

## Технічні особливості та контекст

1. **Lazy Initialization**: Використання `dagger.Lazy` для `ChatDao` та `MessageDao` запобігає спробам ініціалізації бази даних до того, як `SessionManager` отримає дешифрований пароль (passphrase).
2. **Асинхронність та Реактивність**:
    * Використання `callbackFlow` для перетворення слухачів Firebase у реактивні потоки Kotlin Flow.
    * `SupervisorJob` та `repoScope` забезпечують стабільність фонових операцій: помилка в одному запиті не зупиняє роботу всього репозиторію.
3. **Безпека Транспорту**: Репозиторії не передають відкритий текст повідомлень. Весь контент перетворюється на Base64-рядки після шифрування перед відправкою в мережу.
4. **Гарантована Доставка**: Використання `await()` для Coroutines гарантує, що операція в базі даних буде завершена успішно перед переходом до наступного кроку бізнес-логіки.