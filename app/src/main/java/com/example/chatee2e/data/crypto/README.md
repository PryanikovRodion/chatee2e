# Пакет: com.example.chatee2e.data.crypto

Даний пакет є ядром безпеки застосунку. Він реалізує архітектуру наскрізного шифрування (E2EE) та забезпечує апаратний захист криптографічних ключів за допомогою системних ресурсів Android.

## Опис компонентів

### 1. CryptoManager (Interface)
Визначає архітектурний контракт для управління життєвим циклом ключів та виконання операцій шифрування/дешифрування. Всі методи спроектовані для забезпечення цілісності та конфіденційності даних.

### 2. CryptoResult (Data Class)
Клас-контейнер для результатів симетричного шифрування.
* **encryptedData: ByteArray** — безпосередньо зашифрований контент.
* **iv: ByteArray** — вектор ініціалізації (Initialization Vector). Критично важливий для дешифрування в режимі GCM.

### 3. CryptoManagerImpl (Singleton)
Технічна реалізація менеджера, інтегрована з **Android KeyStore**.
* **Аліаси ключів:**
    * `chatee2e_identity_rsa`: Пара RSA для ідентифікації та обміну сесійними ключами.
    * `chatee2e_db_master_key`: Майстер-ключ AES для захисту локального сховища.

---

## Деталізація функцій та алгоритмів

### Управління ідентичністю (RSA-2048)
* **ensureKeyPairExists()**: Виконує перевірку наявності апаратного ключа. Якщо ключ відсутній, генерує пару RSA (2048 біт) у захищеному середовищі (TEE).
* **getMyPublicKeyBase64()**: Вилучає публічний ключ із KeyStore та конвертує його в рядок **Base64**. Цей рядок публікується у Firebase Firestore, що дозволяє іншим клієнтам зашифрувати сесійний ключ для цього користувача.
* **encryptAesKeyWithRsa(aesKey, publicKey)**: Приймає згенерований сесійний ключ AES та публічний ключ отримувача. Повертає зашифрований масив байтів. Ця функція забезпечує безпечну передачу секрету через незахищений сервер.



### Шифрування повідомлень (AES-256 GCM)
* **generateRandomAesKey()**: Використовує `KeyGenerator` для створення унікального 256-бітного ключа. Кожне повідомлення або чат-сесія використовує новий ключ для забезпечення властивості Perfect Forward Secrecy.
* **encryptMsg(text, aesKey)**: Виконує трансформацію `AES/GCM/NoPadding`.
    * **Вхід:** Рядок тексту та SecretKey.
    * **Процес:** Cipher автоматично генерує новий IV для кожної операції.
    * **Вихід:** Об'єкт `CryptoResult`.
* **decryptMsg(encryptedData, iv, aesKey)**: Виконує дешифрування. Режим GCM автоматично перевіряє аутентифікаційний тег — якщо дані були змінені в базі, функція видасть виключення.

### Захист локальної бази даних
* **createMasterKey()**: Генерує ключ AES-256 з прапорцем `setUserAuthenticationRequired(true)`. Це означає, що доступ до ключа буде заблоковано до моменту успішної біометричної автентифікації користувача.
* **generateAndEncryptDatabasePassphrase()**:
    1. Створює випадкові 32 байти (пароль для SQLCipher).
    2. Шифрує їх майстер-ключем.
    3. Повертає `Pair`, де перший елемент — відкриті байти для негайної ініціалізації БД, а другий — зашифрований результат для збереження в налаштуваннях.
* **decryptDatabasePassphrase(data, iv)**: Використовується при повторному вході. Дешифрує збережений пароль бази даних після отримання доступу до майстер-ключа через біометрію.



## Контекст та безпека
1. **Thread Safety**: Всі операції шифрування (особливо `doFinal`) є обчислювально складними і повинні виконуватися в контексті `Dispatchers.Default`.
2. **Гарантоване видалення (deleteKeys)**: Повністю видаляє всі записи з Android KeyStore. Після виклику цього методу відновлення доступу до зашифрованої бази даних або старих повідомлень стає технічно неможливим, реалізуючи принцип "права на забуття".