# Пакет: com.example.chatee2e.domain.repository

Даний пакет містить інтерфейси репозиторіїв, які визначають функціональні межі системи та описують доступні операції над даними. Згідно з принципами **Clean Architecture**, доменні репозиторії є абстракціями, які дозволяють шару бізнес-логіки взаємодіяти з даними, не знаючи про існування Firebase, Room чи KeyStore.

## Склад пакета та функціональні контракти

### 1. AuthRepository
Визначає методи для управління життєвим циклом користувача та його безпекою.
* **currentUser**: Реактивний потік (`Flow`), що транслює стан авторизації поточного користувача.
* **signUp / signIn**: Операції реєстрації та входу.
* **deleteAccount**: Видалення облікового запису (потребує пароль для ре-автентифікації).
* **isKeysSetUp**: Перевірка наявності згенерованих криптографічних ключів на пристрої.
* **searchUserByEmail / getUserById**: Методи для пошуку та ідентифікації інших учасників системи.

### 2. ChatRepository
Керує структурою спілкування (чатами) та синхронізацією.
* **connect()**: Ініціалізація зв'язку, налаштування слухачів мережевих подій та перевірка ключів бази даних.
* **getChats()**: Потік списку доступних чатів у реальному часі.
* **createGroup / createDirectChat**: Створення нових просторів для спілкування (групових або приватних).
* **addMembers / leaveChat**: Управління складом учасників та членством у чатах.



### 3. MessageRepository
Відповідає за обмін повідомленнями та роботу з історією.
* **getMessages(chatId)**: Отримання потоку повідомлень для конкретного діалогу. Саме за цим інтерфейсом прихована логіка автоматичного дешифрування вхідних пакетів.
* **sendMessage**: Підготовка та відправка нового повідомлення.
* **clearHistory**: Локальне очищення історії листування для конкретного чату.

### 4. UserRepository
Описує соціальні взаємодії та управління контактами.
* **getAllUsers**: Отримання списку всіх зареєстрованих користувачів системи.
* **blockUser / unblockUser**: Механізми управління списком блокування (чорним списком).
* **getBlockedUsers**: Реактивне отримання списку заблокованих контактів.

## Роль інтерфейсів у системі

1. **Dependency Inversion (Інверсія залежностей)**: Шар `domain` не залежить від `data`. Навпаки, реалізації в шарі `data` (наприклад, `AuthRepositoryImpl`) залежать від цих інтерфейсів. Це дозволяє легко замінити Firebase на будь-який інший бекенд без зміни бізнес-логіки.
2. **Типізація Resource**: Більшість методів повертають обгортку `Resource<T>`. Це дозволяє стандартизовано обробляти стани успіху, помилок та завантаження на рівні інтерфейсу користувача.
3. **Реактивність через Flow**: Використання `Flow` у методах отримання даних гарантує, що інтерфейс завжди відображатиме актуальний стан бази даних або мережі без ручного оновлення.



## Технічні вимоги до реалізацій
Будь-яка реалізація цих інтерфейсів (зокрема в пакеті `data.repository`) повинна гарантувати:
* **Потокобезпечність**: виконання важких операцій у відповідних диспетчерах (IO).
* **Цілісність**: використання транзакцій або атомарних операцій при роботі з БД та мережею.
* **Безпеку**: обов'язкове використання криптографічних інструментів перед передачею даних через `MessageRepository`.